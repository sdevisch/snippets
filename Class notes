

Atomicity: a task is done, or it is not.

Auditability: we know which code produced which result, and vice versa

Context manager: defines what happens before and after a bit of code
it's a class that defines an __enter__ and __exit__ function

Cyclomatic complexity: count nr of if statements
Reduce to make testing and collaboration easier.n

Deployment: any result which drives a decision, programatic or otherwise.

Evolvability: be resilient to changing data

Idempotent: conforming - an environment or data - to an expected state.
Don't say: do this. Say: I want this + define when I want x, this is how to solve it. Easier to test as a unit.
Idempotence: From a RESTful service standpoint, for an operation (or service call) to be idempotent,
clients can make that same call repeatedly while producing the same result.
In other words, making multiple identical requests has the same effect as making a single request.
Note that while idempotent operations produce the same result on the server (no side effects),
the response itself may not be the same (e.g. a resource's state may change between requests).

Stateless (functions): ideally functions are stateless: they take an input, produce an output, and don't change anything else .

Make sure your code has consistent input and output data types

Code as data examples
Flow based
Object based (oriented) programming
Aspect based programming

Class3
Environments
    - Root: global set of tools
    - Application: intended for deployment on other computers
    - Library:  intended to be used in multiple applications
                don't run directly
                must be designed to use multiple package versions
                you may have a development app for a  library
    - Pipenv: declaratively define a set of dependencies in "code"
    - Pipfile / setup.py: abstract requirements; minimum set of requirements
    - Piplock / requirements.txt: frozen app requirements
 Commands
 pipenv graph







